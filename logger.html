<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mega Max Browser Forensic Lab</title>
    <style>
        body { background: #050505; color: #00ff41; font-family: 'Courier New', monospace; padding: 20px; line-height: 1.4; }
        .red { color: #ff003c; font-weight: bold; }
        #log { border: 1px solid #333; padding: 10px; height: 400px; overflow-y: auto; background: #000; margin-top: 10px; font-size: 12px; }
        h1 { border-bottom: 2px solid #00ff41; padding-bottom: 5px; }
    </style>
</head>
<body>
    <h1>SYSTEM FORENSICS: ACTIVE</h1>
    <div id="status">Analyzing browser internals...</div>
    <div id="log"></div>

    <script>
        const WEBHOOK_URL = 'YOUR_WEBHOOK_URL_HERE';
        const report = { redFlags: [], hardware: {}, software: {}, fingerprints: {}, timing: {} };

        function log(msg, isError = false) {
            const div = document.createElement('div');
            div.innerHTML = `[${new Date().toLocaleTimeString()}] ${isError ? '<span class="red">!!</span> ' : '> '}${msg}`;
            document.getElementById('log').appendChild(div);
        }

        async function runForensics() {
            log("Initiating Deep Scan...");

            // --- 1. PROTOTYPE TAMPERING (The "Liar" Check) ---
            // Antidetect browsers "wrap" native functions. We check for non-native strings.
            try {
                const checkNative = (obj, method) => {
                    const str = obj[method].toString();
                    return str.includes('[native code]') && !str.includes('proxied');
                };
                report.integrity = {
                    canvasNative: checkNative(HTMLCanvasElement.prototype, 'toDataURL'),
                    audioNative: checkNative(AudioContext.prototype, 'createOscillator'),
                    navigatorNative: checkNative(Object.getPrototypeOf(navigator), 'userAgent')
                };
                if (Object.values(report.integrity).some(v => v === false)) {
                    report.redFlags.push("FUNCTION_WRAPPING_DETECTED");
                    log("Tampering detected in Native APIs!", true);
                }
            } catch(e) {}

            // --- 2. HARDWARE CONCURRENCY: THE THREAD TRAP ---
            // Antidetect says "2 cores," but we try to spawn 20 workers.
            log("Testing physical CPU limits...");
            const workerTest = await new Promise(resolve => {
                let workers = [];
                try {
                    for (let i = 0; i < 20; i++) {
                        workers.push(new Worker(URL.createObjectURL(new Blob(['']))));
                    }
                } catch (e) {}
                const actual = workers.length;
                workers.forEach(w => w.terminate());
                resolve(actual);
            });
            report.hardware.reportedCores = navigator.hardwareConcurrency;
            report.hardware.actualSpawned = workerTest;
            if (workerTest > navigator.hardwareConcurrency) {
                report.redFlags.push("CPU_CORES_SPOOFED");
                log(`CPU Mismatch: Claims ${navigator.hardwareConcurrency}, actually supports ${workerTest}+`, true);
            }

            // --- 3. GPU ARCHITECTURE (WebGL Side-Channel) ---
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl');
            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            report.hardware.gpu = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'Unknown';
            
            // Performance Benchmark: A real GPU clears a buffer instantly.
            const t0 = performance.now();
            for(let i=0; i<10000; i++) gl.clear(gl.COLOR_BUFFER_BIT);
            report.timing.gpuBenchmark = (performance.now() - t0).toFixed(2) + "ms";

            // --- 4. THE "HIDDEN" NETWORK (WebRTC) ---
            log("Probing WebRTC for IP leaks...");
            report.network = { localIPs: await getIPs() };

            // --- 5. FONT & MEDIA ENUMERATION ---
            report.software.fonts = ['Consolas', 'Ubuntu', 'Helvetica Neue', 'Arial'].filter(f => document.fonts.check(`12px "${f}"`));
            
            // --- 6. BEHAVIORAL: WINDOW GEOMETRY ---
            // If it's "Mobile" but window.innerWidth is 1920, it's a lie.
            report.software.isMobile = /Mobi|Android/i.test(navigator.userAgent);
            report.software.resMismatch = (report.software.isMobile && window.innerWidth > 1000);
            if (report.software.resMismatch) report.redFlags.push("MOBILE_UA_ON_DESKTOP_RES");

            // Final Send
            log("Full diagnostic package ready. Transmitting...");
            sendReport();
        }

        async function getIPs() {
            return new Promise(resolve => {
                const ips = [];
                const pc = new RTCPeerConnection({iceServers: []});
                pc.createDataChannel("");
                pc.createOffer().then(o => pc.setLocalDescription(o));
                pc.onicecandidate = (i) => {
                    if (!i.candidate) resolve(ips);
                    const match = /([0-9]{1,3}(\.[0-9]{1,3}){3})/.exec(i.candidate.candidate);
                    if (match && !ips.includes(match[1])) ips.push(match[1]);
                };
                setTimeout(() => resolve(ips), 800);
            });
        }

        function sendReport() {
            fetch(WEBHOOK_URL, {
                method: 'POST',
                mode: 'no-cors',
                body: JSON.stringify({ ...report, userAgent: navigator.userAgent })
            });
            document.getElementById('status').innerText = "FORENSICS SENT TO WEBHOOK.";
            log("Check Webhook.site dashboard for the 'redFlags' array.");
        }

        window.onload = runForensics;
    </script>
</body>
</html>
